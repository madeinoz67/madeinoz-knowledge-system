#!/usr/bin/env bun
/**
 * Unified server management tool for madeinoz-knowledge-system
 * Consolidates start, stop, restart, status, and logs commands
 * @module src/skills/tools/server-cli.ts
 */
import { join } from 'node:path';
import { createComposeManager, ComposeManager, type DatabaseBackend } from '../lib/container.js';
import { createConfigLoader, loadConfig, type KnowledgeConfig } from '../lib/config.js';
import { cli } from '../lib/cli.js';

const serverDir = join(import.meta.dir, '../server');

// Parse command and flags
const args = process.argv.slice(2);
const command = args[0]?.toLowerCase() || 'help';

// Extract flags
const flags = {
  dev: args.includes('--dev') || args.includes('-d'),
  mcp: args.includes('--mcp'),
  db: args.includes('--db'),
  noFollow: args.includes('--no-follow'),
  tail: (() => {
    const tailIdx = args.indexOf('--tail');
    if (tailIdx !== -1 && args[tailIdx + 1]) {
      return Number.parseInt(args[tailIdx + 1], 10);
    }
    return 100;
  })(),
};

/**
 * Generate environment files for containers
 * Maps MADEINOZ_KNOWLEDGE_* prefixed variables to unprefixed container variables
 * Creates /tmp/madeinoz-knowledge-*.env files that compose files reference
 */
async function generateEnvFiles(
  config: KnowledgeConfig,
  databaseType: DatabaseBackend,
  devMode = false
): Promise<void> {
  const configLoader = createConfigLoader();
  const containerEnv = configLoader.getContainerEnv(config);

  // Determine file paths based on mode
  const envFiles = devMode
    ? {
        neo4j: ComposeManager.ENV_FILES.neo4jDev,
        mcp: ComposeManager.ENV_FILES.mcpDev,
      }
    : {
        neo4j: ComposeManager.ENV_FILES.neo4j,
        mcp: ComposeManager.ENV_FILES.mcp,
      };

  // Generate Neo4j env file (minimal - just auth)
  const defaultPassword = devMode ? 'devpassword' : 'madeinozknowledge';
  const neo4jContent = [
    '# Generated by server.ts - Neo4j container environment',
    `# Generated: ${new Date().toISOString()}`,
    '',
    `NEO4J_PASSWORD=${config.NEO4J_PASSWORD || defaultPassword}`,
    '',
  ].join('\n');

  await Bun.write(envFiles.neo4j, neo4jContent);
  cli.dim(`  Generated: ${envFiles.neo4j}`);

  // Generate MCP server env file (full config)
  const mcpLines = [
    '# Generated by server.ts - MCP server environment',
    `# Generated: ${new Date().toISOString()}`,
    '',
    '# LLM Provider Configuration',
    `LLM_PROVIDER=${containerEnv.LLM_PROVIDER}`,
    `MODEL_NAME=${containerEnv.MODEL_NAME}`,
    '',
    '# API Keys',
  ];

  // Add API keys (only if set)
  if (containerEnv.OPENAI_API_KEY) mcpLines.push(`OPENAI_API_KEY=${containerEnv.OPENAI_API_KEY}`);
  if (containerEnv.OPENAI_BASE_URL)
    mcpLines.push(`OPENAI_BASE_URL=${containerEnv.OPENAI_BASE_URL}`);
  if (containerEnv.ANTHROPIC_API_KEY)
    mcpLines.push(`ANTHROPIC_API_KEY=${containerEnv.ANTHROPIC_API_KEY}`);
  if (containerEnv.GOOGLE_API_KEY) mcpLines.push(`GOOGLE_API_KEY=${containerEnv.GOOGLE_API_KEY}`);
  if (containerEnv.GROQ_API_KEY) mcpLines.push(`GROQ_API_KEY=${containerEnv.GROQ_API_KEY}`);
  if (containerEnv.VOYAGE_API_KEY) mcpLines.push(`VOYAGE_API_KEY=${containerEnv.VOYAGE_API_KEY}`);

  mcpLines.push('');
  mcpLines.push('# Embedder Configuration');
  mcpLines.push(`EMBEDDER_PROVIDER=${containerEnv.EMBEDDER_PROVIDER}`);
  if (containerEnv.EMBEDDER_MODEL) mcpLines.push(`EMBEDDER_MODEL=${containerEnv.EMBEDDER_MODEL}`);
  if (containerEnv.EMBEDDER_DIMENSIONS)
    mcpLines.push(`EMBEDDER_DIMENSIONS=${containerEnv.EMBEDDER_DIMENSIONS}`);
  if (containerEnv.EMBEDDER_PROVIDER_URL)
    mcpLines.push(`EMBEDDER_PROVIDER_URL=${containerEnv.EMBEDDER_PROVIDER_URL}`);

  mcpLines.push('');
  mcpLines.push('# Database Configuration');
  mcpLines.push(`DATABASE_TYPE=${databaseType}`);

  if (databaseType === 'neo4j') {
    mcpLines.push(`NEO4J_URI=${containerEnv.NEO4J_URI || 'bolt://neo4j:7687'}`);
    mcpLines.push(`NEO4J_USER=${containerEnv.NEO4J_USER}`);
    mcpLines.push(`NEO4J_PASSWORD=${containerEnv.NEO4J_PASSWORD}`);
  } else {
    mcpLines.push(`FALKORDB_HOST=${containerEnv.FALKORDB_HOST}`);
    mcpLines.push(`FALKORDB_PORT=${containerEnv.FALKORDB_PORT}`);
    if (containerEnv.FALKORDB_PASSWORD)
      mcpLines.push(`FALKORDB_PASSWORD=${containerEnv.FALKORDB_PASSWORD}`);
  }

  mcpLines.push('');
  mcpLines.push('# Qdrant Configuration (LKAP - Document Memory)');
  if (containerEnv.QDRANT_URL) mcpLines.push(`QDRANT_URL=${containerEnv.QDRANT_URL}`);
  if (containerEnv.QDRANT_API_KEY) mcpLines.push(`QDRANT_API_KEY=${containerEnv.QDRANT_API_KEY}`);
  if (containerEnv.QDRANT_COLLECTION) mcpLines.push(`QDRANT_COLLECTION=${containerEnv.QDRANT_COLLECTION}`);
  if (containerEnv.QDRANT_EMBEDDING_DIMENSION)
    mcpLines.push(`QDRANT_EMBEDDING_DIMENSION=${containerEnv.QDRANT_EMBEDDING_DIMENSION}`);
  if (containerEnv.QDRANT_CONFIDENCE_THRESHOLD)
    mcpLines.push(`QDRANT_CONFIDENCE_THRESHOLD=${containerEnv.QDRANT_CONFIDENCE_THRESHOLD}`);
  if (containerEnv.QDRANT_CHUNK_SIZE_MIN)
    mcpLines.push(`QDRANT_CHUNK_SIZE_MIN=${containerEnv.QDRANT_CHUNK_SIZE_MIN}`);
  if (containerEnv.QDRANT_CHUNK_SIZE_MAX)
    mcpLines.push(`QDRANT_CHUNK_SIZE_MAX=${containerEnv.QDRANT_CHUNK_SIZE_MAX}`);
  if (containerEnv.QDRANT_CHUNK_OVERLAP)
    mcpLines.push(`QDRANT_CHUNK_OVERLAP=${containerEnv.QDRANT_CHUNK_OVERLAP}`);
  if (containerEnv.QDRANT_LOG_LEVEL)
    mcpLines.push(`QDRANT_LOG_LEVEL=${containerEnv.QDRANT_LOG_LEVEL}`);
  // Ollama (for embeddings)
  if (containerEnv.OLLAMA_BASE_URL)
    mcpLines.push(`OLLAMA_BASE_URL=${containerEnv.OLLAMA_BASE_URL}`);
  if (containerEnv.OLLAMA_EMBEDDING_MODEL)
    mcpLines.push(`OLLAMA_EMBEDDING_MODEL=${containerEnv.OLLAMA_EMBEDDING_MODEL}`);
  // Vision LLM (Feature 024 - Multimodal Image Extraction)
  if (containerEnv.VISION_LLM_PROVIDER)
    mcpLines.push(`VISION_LLM_PROVIDER=${containerEnv.VISION_LLM_PROVIDER}`);
  if (containerEnv.VISION_LLM_MODEL)
    mcpLines.push(`VISION_LLM_MODEL=${containerEnv.VISION_LLM_MODEL}`);
  if (containerEnv.VISION_LLM_FALLBACK)
    mcpLines.push(`VISION_LLM_FALLBACK=${containerEnv.VISION_LLM_FALLBACK}`);
  if (containerEnv.OPENROUTER_API_KEY)
    mcpLines.push(`OPENROUTER_API_KEY=${containerEnv.OPENROUTER_API_KEY}`);
  if (containerEnv.ZAI_API_KEY)
    mcpLines.push(`ZAI_API_KEY=${containerEnv.ZAI_API_KEY}`);

  mcpLines.push('');
  mcpLines.push('# Application Configuration');
  mcpLines.push(`SEMAPHORE_LIMIT=${containerEnv.SEMAPHORE_LIMIT}`);
  mcpLines.push(`GROUP_ID=${containerEnv.GROUP_ID}`);
  mcpLines.push(`GRAPHITI_GROUP_ID=${containerEnv.GROUP_ID}`);
  mcpLines.push(`GRAPHITI_TELEMETRY_ENABLED=${containerEnv.GRAPHITI_TELEMETRY_ENABLED}`);
  mcpLines.push('');

  // Prompt Caching Configuration (Gemini)
  if (containerEnv.PROMPT_CACHE_ENABLED) {
    mcpLines.push('# Prompt Caching Configuration');
    mcpLines.push(`PROMPT_CACHE_ENABLED=${containerEnv.PROMPT_CACHE_ENABLED}`);
    if (containerEnv.PROMPT_CACHE_METRICS_ENABLED)
      mcpLines.push(`PROMPT_CACHE_METRICS_ENABLED=${containerEnv.PROMPT_CACHE_METRICS_ENABLED}`);
    if (containerEnv.PROMPT_CACHE_LOG_REQUESTS)
      mcpLines.push(`PROMPT_CACHE_LOG_REQUESTS=${containerEnv.PROMPT_CACHE_LOG_REQUESTS}`);
    if (containerEnv.PROMPT_CACHE_TTL)
      mcpLines.push(`PROMPT_CACHE_TTL=${containerEnv.PROMPT_CACHE_TTL}`);
    if (containerEnv.METRICS_PORT)
      mcpLines.push(`METRICS_PORT=${containerEnv.METRICS_PORT}`);
    mcpLines.push('');
  }

  await Bun.write(envFiles.mcp, mcpLines.join('\n'));
  cli.dim(`  Generated: ${envFiles.mcp}`);
}

/**
 * Start the server containers
 */
async function start(): Promise<void> {
  cli.header('Starting Knowledge System');

  const compose = createComposeManager(serverDir);

  // Check if runtime is available
  if (!compose.isRuntimeAvailable()) {
    cli.error('No container runtime found!');
    process.exit(1);
  }

  cli.success(`Using container runtime: ${compose.getRuntimeCommand()}`);
  cli.blank();

  if (flags.dev) {
    cli.info('*** DEVELOPMENT MODE ***');
    cli.blank();
  }

  // Load configuration to determine database type
  const config = await loadConfig();
  const databaseType = (config.DATABASE_TYPE || 'neo4j') as DatabaseBackend;

  cli.info(`Database backend: ${databaseType}`);
  cli.blank();

  // Generate environment files for containers
  cli.info('Generating container environment files...');
  await generateEnvFiles(config, databaseType, flags.dev);
  cli.blank();

  // Get compose file path for display
  const composeFile = compose.getComposeFilePath(databaseType, flags.dev);
  cli.dim(`Compose file: ${composeFile}`);
  cli.blank();

  // Start containers
  cli.info('Starting containers...');
  const result = await compose.up(databaseType, flags.dev);

  if (result.success) {
    cli.success('Server started successfully');
    cli.blank();

    // Show access URLs
    cli.info('Access Points:');
    if (databaseType === 'neo4j') {
      const browserPort = flags.dev ? 7475 : 7474;
      cli.url('Neo4j Browser', `http://localhost:${browserPort}`);
      cli.url('Bolt', `bolt://localhost:${flags.dev ? 7688 : 7687}`);
    } else {
      const falkorPort = flags.dev ? 3001 : 3000;
      cli.url('FalkorDB Browser', `http://localhost:${falkorPort}`);
      cli.url('Redis', 'localhost:6379');
    }
    const mcpPort = flags.dev ? 8001 : 8000;
    cli.url('MCP Server', `http://localhost:${mcpPort}/mcp/`);
  } else {
    cli.error(`Failed to start: ${result.stderr || 'Unknown error'}`);
    process.exit(1);
  }
}

/**
 * Stop the server containers
 */
async function stop(): Promise<void> {
  cli.header('Stopping Knowledge System');

  const compose = createComposeManager(serverDir);

  // Check if runtime is available
  if (!compose.isRuntimeAvailable()) {
    cli.error('No container runtime found!');
    process.exit(1);
  }

  cli.success(`Using container runtime: ${compose.getRuntimeCommand()}`);
  cli.blank();

  if (flags.dev) {
    cli.info('*** DEVELOPMENT MODE ***');
    cli.blank();
  }

  // Load configuration to determine database type
  const config = await loadConfig();
  const databaseType = (config.DATABASE_TYPE || 'neo4j') as DatabaseBackend;

  cli.info(`Database backend: ${databaseType}`);
  cli.blank();

  // Stop containers
  cli.info('Stopping containers...');
  const result = await compose.down(databaseType, flags.dev);

  if (result.success) {
    cli.success('Server stopped successfully');
  } else {
    cli.error(`Failed to stop: ${result.stderr || 'Unknown error'}`);
    process.exit(1);
  }
}

/**
 * Restart the server containers
 */
async function restart(): Promise<void> {
  cli.header('Restarting Knowledge System');

  const compose = createComposeManager(serverDir);

  // Check if runtime is available
  if (!compose.isRuntimeAvailable()) {
    cli.error('No container runtime found!');
    process.exit(1);
  }

  cli.success(`Using container runtime: ${compose.getRuntimeCommand()}`);
  cli.blank();

  if (flags.dev) {
    cli.info('*** DEVELOPMENT MODE ***');
    cli.blank();
  }

  // Load configuration to determine database type
  const config = await loadConfig();
  const databaseType = (config.DATABASE_TYPE || 'neo4j') as DatabaseBackend;

  cli.info(`Database backend: ${databaseType}`);
  cli.blank();

  // Generate environment files for containers (needed for dev mode)
  cli.info('Regenerating container environment files...');
  await generateEnvFiles(config, databaseType, flags.dev);
  cli.blank();

  // Restart containers
  cli.info('Restarting containers...');
  const result = await compose.restart(databaseType, undefined, flags.dev);

  if (result.success) {
    cli.success('Server restarted successfully');
    cli.blank();

    // Show access URLs
    cli.info('Access Points:');
    if (databaseType === 'neo4j') {
      const browserPort = flags.dev ? 7475 : 7474;
      cli.url('Neo4j Browser', `http://localhost:${browserPort}`);
      cli.url('Bolt', `bolt://localhost:${flags.dev ? 7688 : 7687}`);
    } else {
      const falkorPort = flags.dev ? 3001 : 3000;
      cli.url('FalkorDB Browser', `http://localhost:${falkorPort}`);
      cli.url('Redis', 'localhost:6379');
    }
    const mcpPort = flags.dev ? 8001 : 8000;
    cli.url('MCP Server', `http://localhost:${mcpPort}/mcp/`);
  } else {
    cli.error(`Failed to restart: ${result.stderr || 'Unknown error'}`);
    process.exit(1);
  }
}

/**
 * Show server status
 */
async function status(): Promise<void> {
  cli.header('Knowledge System Status');

  const compose = createComposeManager(serverDir);

  // Check if runtime is available
  if (!compose.isRuntimeAvailable()) {
    cli.error('No container runtime found!');
    process.exit(1);
  }

  cli.success(`Using container runtime: ${compose.getRuntimeCommand()}`);
  cli.blank();

  if (flags.dev) {
    cli.info('*** DEVELOPMENT MODE ***');
    cli.blank();
  }

  // Load configuration to determine database type
  const config = await loadConfig();
  const databaseType = (config.DATABASE_TYPE || 'neo4j') as DatabaseBackend;

  cli.info(`Database backend: ${databaseType}`);
  cli.blank();

  // Get compose file path for display
  const composeFile = compose.getComposeFilePath(databaseType, flags.dev);
  cli.dim(`Compose file: ${composeFile}`);
  cli.blank();

  // Get container status using docker-compose ps
  cli.info('Container Status:');
  cli.blank();

  const result = await compose.ps(databaseType, flags.dev);

  if (result.success && result.stdout) {
    console.log(result.stdout);
  } else if (result.stderr) {
    cli.warning('Could not get container status');
    cli.dim(result.stderr);
  }

  cli.blank();

  // Determine ports based on database type and mode
  const mcpPort = flags.dev ? 8001 : 8000;
  const dbPort = databaseType === 'neo4j' ? (flags.dev ? 7475 : 7474) : flags.dev ? 3001 : 3000;
  const dbName = databaseType === 'neo4j' ? 'Neo4j Browser' : 'FalkorDB UI';

  // Test health endpoint
  cli.info('Health Check:');
  cli.blank();

  try {
    const healthUrl = `http://localhost:${mcpPort}/health`;
    const response = await fetch(healthUrl, {
      signal: AbortSignal.timeout(5000),
    });

    if (response.ok) {
      const data = await response.json();
      if (data.status === 'healthy' || data.status === 'ok') {
        cli.success('  MCP Server: healthy');
      } else {
        cli.warning(`  MCP Server: ${data.status}`);
      }
    } else {
      cli.warning('  MCP Server: unhealthy (server may be starting up)');
    }
  } catch {
    cli.warning('  MCP Server: not responding (server may be starting up)');
  }

  cli.blank();
  cli.separator();
  cli.blank();

  // Display access URLs
  cli.info('Access Points:');
  cli.url(`  ${dbName}`, `http://localhost:${dbPort}`);
  cli.url('  MCP Server', `http://localhost:${mcpPort}/mcp/`);
  cli.url('  Health Check', `http://localhost:${mcpPort}/health`);
  cli.blank();

  // Check if services are running
  const isRunning = await compose.isRunning(databaseType, flags.dev);

  if (isRunning) {
    cli.success('System operational');
    process.exit(0);
  } else {
    cli.warning('System not fully running');
    cli.blank();
    cli.info('To start the system:');
    cli.dim('  bun run server start');
    process.exit(1);
  }
}

/**
 * Show container logs
 */
async function logs(): Promise<void> {
  const compose = createComposeManager(serverDir);

  // Check if runtime is available
  if (!compose.isRuntimeAvailable()) {
    cli.error('No container runtime found!');
    process.exit(1);
  }

  // Load configuration to determine database type
  const config = await loadConfig();
  const databaseType = (config.DATABASE_TYPE || 'neo4j') as DatabaseBackend;

  // Determine which service to show logs for
  let service: string | undefined;
  if (flags.mcp) {
    service = 'graphiti-mcp';
  } else if (flags.db) {
    service = databaseType === 'neo4j' ? 'neo4j' : 'falkordb';
  }

  const header = service ? `Logs: ${service}` : 'Logs: all services';
  cli.header(header);
  cli.info(`Backend: ${databaseType}`);
  cli.info(`Runtime: ${compose.getRuntimeCommand()}`);
  cli.separator();

  // Get logs (this will stream if follow is enabled)
  const result = await compose.logs(
    databaseType,
    service,
    !flags.noFollow, // follow
    flags.dev,
    flags.tail
  );

  if (!result.success) {
    cli.error(`Failed to get logs: ${result.stderr || 'Unknown error'}`);
    process.exit(1);
  }

  // Output logs
  if (result.stdout) {
    console.log(result.stdout);
  }
}

/**
 * Show help
 */
function showHelp(): void {
  console.log(`
Usage: bun run server-cli <command> [options]

Commands:
  start     Start the server containers
  stop      Stop the server containers
  restart   Restart the server containers
  status    Show server status and health
  logs      Show container logs

Options:
  --dev, -d     Use development configuration
  --mcp         (logs) Show only MCP server logs
  --db          (logs) Show only database logs
  --tail N      (logs) Number of lines to show (default: 100)
  --no-follow   (logs) Don't follow log output

Examples:
  bun run server-cli start
  bun run server-cli stop
  bun run server-cli restart
  bun run server-cli status
  bun run server-cli logs --mcp --tail 50
  bun run server-cli logs --db --no-follow
`);
}

// Main execution
async function main(): Promise<void> {
  try {
    switch (command) {
      case 'start':
        await start();
        break;
      case 'stop':
        await stop();
        break;
      case 'restart':
        await restart();
        break;
      case 'status':
        await status();
        break;
      case 'logs':
        await logs();
        break;
      case 'help':
      case '--help':
      case '-h':
        showHelp();
        break;
      default:
        cli.error(`Unknown command: ${command}`);
        showHelp();
        process.exit(1);
    }
  } catch (error) {
    cli.error(`Error: ${error instanceof Error ? error.message : String(error)}`);
    process.exit(1);
  }
}

main();
